import * as crypto from 'crypto';

/**
 * Function to generate a random numeric code of a given length
 * @param length 
 * @returns 
 */
export function genCode(length: number): string {
  // Repeat '0' for the given length, split it into an array,
  // replace each '0' with a random digit from 0 to 9, and join them back into a string
  return '0'
    .repeat(length)
    .split('')
    .map(() => Math.floor(Math.random() * 10))
    .join('');
}

/**
 * Function to generate a random password of a given length
 * 
 * @param length 
 * @returns 
 */
export function genPasswordRandom(length: number): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+';
  let password = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    password += characters.charAt(randomIndex);
  }
  return password;
}

/**
 * Function to generate a random flag of a given length
 * 
 * @param length 
 * @returns 
 */
export function genFlagRandom(length: number): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let flag = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    flag += characters.charAt(randomIndex);
  }
  
  return flag;
}

/**
 * Function to generate a QR code from a data hash
 * 
 * @param dataHash 
 * @returns 
 */
export function genQRCode(dataHash: string): string {
  return crypto
    .createHmac('sha256', 'AT_SECRET_ENTERPRISE')
    .update(dataHash)
    .digest('hex');
}

/**
 * Function to generate a random positive integer
 * 
 * @returns 
 */
export function randomPositiveInteger(): number {
  const randomNumber = Math.random();
  const result = Math.floor(randomNumber * Number.MAX_SAFE_INTEGER) + 1;
  return result;
}

/**
 * Function to generate a nested population object for a given level and path
 * 
 * @param level 
 * @param path 
 * @returns 
 */
export function generateNestedPopulation(level: number, path: string): any {
  // If the level is 0, return the path
  if (level === 0) {
    return path;
  } else {
    // Otherwise, return an object with the path and a nested population object
    // The nested population object is generated by a recursive call to this function
    // with the level decreased by 1
    return {
      path: path,
      populate: generateNestedPopulation(level - 1, path)
    };
  }
}
